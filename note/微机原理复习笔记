8086CPU有16条数据总线、20条地址总线，16条控制总线
存储器有几个模块组成，每个模块包含有多个存储单元，每个存储单元
可存储指令和数据，每个存储单元都有一个唯一的地址，CPU依据这个地址来存取
指令和数据，用高地址来区分模块
大多数存储器都采用独立的地址空间，存储器地址空间和IO地址空间，这是某存储单元和IO端口
可能对应与相同的地址值。
那如何区分CPU是存取存储单元和IO端口？采用存储器读写信号和IO读写信号来区分。
这种方式下，对存储器和对IO端口读写指令是不同的

在8086CPU中采用20位地址对存储器进行变址，可寻址范围是2的20次方即1M，采用16位地址对IO端口编址，所以
可寻址范围是2的16次方　65536个端口寄存器

EU执行指令规定的操作，主要部件有运算逻辑单元，暂存器，EU控制器，微处理器状态字和通用寄存器组
BIU主要完成CPU与存储器和IO设备之间的传递信息，主要部件：运算逻辑单元，段寄存器，指令寄存器，指令
指针，内部寄存器，指令寄存器和总线控制电路

BIU主要完成取指令，存取数据的操作，其中ALU用于计算20位的指令或者数据的地址，读取的指令代码存入指令队列
寄存器，读取到数据通过ALU总线直接送给EU。而EU直接从指令队列寄存器中获取指令，通过寄存、译码产生控制信号，
完成指令规定的操作

EU和BIU可以独立，并发运行，但是相互之间会有协作。

微处理器中的寄存器组织
通用寄存器可以分成两类：数据寄存器和地址寄存器(AX，BX，CX，DX)/变址寄存器(SI，DI，SP，BP)。

8086CPU有4个16为寄存器：
(1)累加器AX，这是最常用的寄存器，许多操作都可以在AX中完成，而且有一些操作只能在AX中完成
(2)基址寄存器　BX，虽然是数据寄存器，但通常被用作地址寄存器。
(3)计数寄存器CX，经常用做循环的计数寄存器
(4)数据寄存器，DX，用于寄存数据，但在IO指令中，DX用于表示端口地址。
变址寄存器：SI，在字符串操作指令中，SI提供源操作数的段内偏移地址，当然也可以在其他指令中用作地址寄存器
变址寄存器：在字符串操作指令中，DI提供目的操作数的段内偏移地址，当然也可以在其他指令中用作地址寄存器
堆栈指针：SP用于保存堆栈段的段内偏移地址。
基址指针：BP可以指定段内偏移地址，但将BP用作地址寄存器时，一般情况下，其默认段地址为SS

段寄存器：CS，DS，ES，SS

控制寄存器：IP程序计数器，保存下一条将要执行指令的段内偏移地址，改变IP的值意味着改编程序的执行流程

PSW微处理器状态字：他是一个16位寄存器，一共设置９个标志位，其中标志位用于反应ALU前一次操作的结果状态，
另外3个标志位用于控制CPU操作。
结果状态的标志位：
进位标志：在减法运算的时候，最高位有无进位的标志
有进位：cf为1
没有进位：cf为0

奇偶标志PF：操作结果的低8位中含有1的个数
偶数个1   pf=1
奇数个1   af=0

辅助进位标志af：在减法运算的时候，d3位有无进位的标志
有进位：af=1
无进位：af=0

零标志：运算结果是否为0
结果为0:zf=1
结果不为0:zf=0

符号标志sf:操作结果的符号：他等同于操作的最高位d7或者d15
操作结果为负　sf=1
操作结果为正  sf=0
溢出标志位of
有符号位运算时，是否溢出的标志
溢出：of=1
没溢出：of=0

控制CPU的标志位有：
方向标志位df：在字符串操作中，当df=0时，其变址寄存器的内容自动增加，当df=1时，si和di自动递减。
中断允许标志位if:当if为1的时候，cpu能够响应可屏蔽中断请求，这一位可以用指令sti，cli来设置
陷阱标志tf：当tf=1的时候，cpu处于单步执行方式，即每执行一条指令就自动执行一次类型1的内部中断，这主要在
debug中


存储器地址空间和数据存储格式
当一个字从偶地址开始存储时，则称为字的存储是对准的；否则当一个字从奇地址开始存储，则称为字的存储是未对准的
这一点与CPU访问一个字时的总线周期与密切关系，从理论上讲，8086CPＵ具有16条数据总线，CPU的一个总线周期可以
存取一个字，但实际上，只有当字的存储是对准的时候，CPU存取一个字需要一个总线周期，当字的存储是为对准时，
CPU存取这个字的时需要两个总线周期。第一个总线周期先访问低字节，第二个总线周期访问高字节

IO端口与存储器的区别：
IO端口与存储器采用两个不同的地址空间，因此，必须分别采用不同的指令来访问，mov指令用于处理存储单元，而IN和OUT指令
用于访问IO端口寄存器。
IO端口寄存器只需要16位地址表示，因此不需要使用段地址

指令系统　

汇编语言中的常数和表达式
常数有以下格式：
二进制　10000000B
十进制　　　　　127D
十六进制　　　　　23H

表达式
算数操作符号
+,-,*,/,mod
逻辑操作符　AND, OR, NOT, XOR
关系操作符　EQ(相等)，EN(不等)，LT(小于)，GT(大于)，LE(小于等于)　GE(大于等于)
属性操作符号
其他操作符

标号，变量和伪指令

标号是由指令语句中所定义的标识符，他与助记符助之间用冒号间隔，用于指示相应的指令地址

段地址：指示标号所在段的段地址
偏移地址：...
类型：如果标号仅在本段内使用，类型(NEAR)否则为FAR

变量定义
变量名称　DB　定义字节变量
DW　字变量
DD 双字变量
DQ 长字变量
DT 定义10字节变量
变量名称与助记符之间用空格，不用冒号
变量名可有可无

变量定义格式：
一个或者多个常数或者表达式，之间用逗号间隔
带引号的字符串
一个、多个问号，这时表示只给变量分配存储空间
重复方式，这时表达式的形式
重复次数　dup(表达式)
var db 12h, 0a5h, 18+20,50/3, 0, -1

数据寻址方式：寻找指令操作所需数据的方法
转移地址的寻址方式：寻找转移指令所需的程序地址的方法

立即寻址：将8为位或者16位数据直接放在指令之后，这种操作数的寻址方式称为立即寻址
寄存器寻址：指令的操作数存放在寄存器中，这种操作数的寻址方式称为寄存器寻址

操作数保存在存储单元中，其16位偏移地址直接在指令中给出，这种方式称为直接寻址

寄存器间接寻址：操作数保存在存储单元中，其有效地址存放在寄存器中，可以使用的寄存器为BX，SI，和DI，以方括号
内的寄存器符指定使用的寄存器，其有效地址的值可以表示成
ea={bx, si, di}
表示成ea的值为bx，si，di的内容
mov ax, [si]
mov [bx], dx

寄存器相对寻址
操作数保存在存储器中，其有效地址为一个基址寄存器或者变址寄存器的内容和一个8位
或者16位的偏移量之和
mov bx, [si+5]
mov bx, [si+5]
mov cx, var[bx]
mov al, var[di-15]
moov 5[si+24]

基址变址寻址
操作数保存在存储器中，其有效地址为一个基址寄存器和一个变址寄存器的内容之和
mov dx, [bx][si]
mov ax, [bp][si]

基址变址且相对寻址
操作数保存在存储器中，其有效地址为一个基址寄存器内容、一个变址寄存器内容、一个
8位或者16位的位移量之和
mov ax, [bx+2][si]
mov dl, [bx+15][di+3]
mov var[bp][di], ax

隐含寻址
movsb 字节操作（es:di）<-(ds:si),(si)<-(si+1),(di)<-(di)+1

从(ds:si)的存储单元中获取一个字节，传送到(es:di)存储单元，并且si和di的内容自动增加1或者自动减一

转移地址的寻址方式
段内直接寻址
段内直接寻址是指直接在指令中给出转移目的地址，转移在同一个段内完成。
JMP LABEL   程序转移到标号label处执行

段内间接寻址
段内间接寻址是指转移目的地址保存在寄存器或者存储单元中，转移也在同一个段内完成，在指令中
之处所使用的寄存器或者存储单元的偏移地址，当采用存储单元保存转移地址时，可以采用上面的五种寻址方式

JMP BX
JMP VAR1
JMP VAR1[SI]

段内直接寻址
段内直接寻址指直接在指令中给出转移目的地址，转移在不同段之间完成。
JMP LABEL
段内间接寻址
JMP VAR3
JMP VAR3[BX]


数据传送类指令
通用：mov dst, src

LEA取有效地址指令
lea reg16, mem
取有效地址指令lea可以将源操作数的有效地址送入16位存储器reg16，它传送的不是mem
的内容，而是存储单元的有效地址，这里，源操作数mem只能是直接寻址方式

lea di, var1

取地址指针指令
lds rehg16, mem
les reg16, mem
取地址指针指令lds可以将双字节变量mem内容中的高16位送入ds，低16位存入指定的reg16中，
而取地址指针指令les可以将双字变量mem内容中的高16位送入es，低16位送入指定的reg16中，这里reg16不允许为段寄存器

table db 10h, 20h....
point1 dd 02001000h
point2 dd table 
lds di, point1　ds<-0200h    di<-1000h
les si, point2  es<-table的段地址　si<-table的偏移地址

标志传送指令
lahf   ah<-psw寄存器的低8位
sahf   psw寄存器的低8位<-ah

xchg 数据交换指令
完成两个操作数之间数据的交换，src和dst可以使寄存器，也可以是存储单元，但两者不能同时为存储单元。
xchg指令可以完成寄存器与寄存器，寄存器与存储单元之间的内容交换

xchg ax, bx
xchg cx, [di]
xchg dx, var1

字节转换单元(xlat)

堆栈操作指令
push pop pushf popf
堆栈的段地址由ss指定，堆栈的偏移地址由sp指定，堆栈操作指令是以sp为间接寄存器的存储器访问
压入堆栈指令push将先修正堆栈指针sp的内容，然后将src或者psw的内容送入堆栈。src必须是字型的，
它可以是通用寄存器和段寄存器还可以是某种寻址方式的存储单元，但不能是立即数

push ax
push ds
push var1
pushf  将psw压入堆栈
弹出堆栈指令(pop)

算数运算类指令

算数运算类指令

加法指令
add dst, src   dst<-src+dst
adc ,dst, src   dst<-src+dst+cf
add 为加法指令，它可以将源操作数src和目的操作数dst的内容相加，存入到dst中
adc 为带进位的加法指令，他可以将src、dst、和cf的内容相加，其结果存入dst中，指令中，
src可以取立即数通用寄存器和存储单元，dst可以取通用寄存器和存储单元，但src和dst不能同时取存储单元

减法指令
sub 指令表示将dst的内容减去src的内容，其结果保存在dst中，sbb指令表示将fst内容减去src内容，结果在dst中
sub dst, src dst<-src
sbb dst, src dst<-dst-src-cf

取负指令
neg dst dst<-0-dst

比较指令
cmp dst src

cmp dst, src

cmp 为比较指令，与减法指令类似，完成dst的内容减去src的内容，设置psw中状态标识位但结果不保存在dst中
若两个数相减结果为０，则两个数相等，则zf=1
sf等同于最高位
cf、of视具体情况而定，当两个无符号数进行比较的时候,如果cf=0、zf=0，则表示dst>src，如果cf=1则表示
dst<src
当两个有符号数进行比较的时候，of=1表示产生了溢出，但大小的比较要根据of和sf共同决定

增量减量指令
inc dst
dec dst
影响的psw值：af, of, sf, zf，pf但是不会影响cf位
乘法除法指令
mul src 无符号相乘
imul src　有符号数相乘
乘数隐藏在al中
当src为字节时，mul和imul为字节运算，这时将al中的数与src相乘，存在ax中
当src是字数据的时候，mul和imul为字运算，这时表示将ax中的数与src相乘，结果的高16位存在dx中，低16为存在ax中
mul和imul指令只对psw中的cf，of影响：
当采用mul进行运算的时候，字运算结果的dx为0时，cf=0，of=0，表示两个字相乘结果也为一个字
字节运算结果的ah为0时，cf=0，of=0，表示两个字节相乘结果为一个字节，否则cf=1，of=1
当采用imul运算的时候，字运算结果的dx为符号扩展时，cf=0，of=0，表示两个字节相乘结果可以用一个字来表示；字节运算结果的ah为扩展时。
cf=0，of=0，表示两个字节现场相乘结果也可以用一个字节表示，否则cf=1,of=1

除法指令
div src 
idiv src

当src为字节时，div和idiv为字节运算，这时表示将ax中的16位二进制数除以8位二进制数，其结果的商保存在al中，余数保存在ah中
当src为字时，div和idiv为字运算，这时表示将dx与ax联合构成32位二进制数src，其结果的商保存在ax中，余数保存在dx中
div和idiv不影响psw的值
符号扩展指令　cbw //将al中的符号扩展到ah中，形成一个字ax
cwd 将ax中的符号扩展到dx，形成双字 dx:ax
逻辑与指令　and dst ,src  对两个操作数进行逻辑与运算，并设置psw的标志位，指令中的dst可以取通用寄存器、存储单元，src可以
取通用寄存器，存储单元和立即数，但是dst和rsc不能同时为存储单元
or 对两个操作数进行逻辑或操作，并设置psw中的标志位，指令中的dst和src的说明等同于and指令

xor异或

移位指令　shr dst,cnt逻辑右移 cnt表示移位的数量
sar dst,cnt   算数右移指令
shl/sal dst,cnt 算数左移指令
ror dst, cnt 循环右移指令
rcr 循环左移指令
rcl带进位循环左移指令
rcr 带进位循环右移指令

clc cf清零
stc   cf置位
cli  if清０
cmc cf取反
sti if置位打开中断
std  df置位
cld  df清零

转移指令：
jmp label  转移到label处开始执行
label为标号，当label与该转移指令位于同一段的时候，则为段内直接转移，转移目的地址cs不变
ip<-(ip)+disp16 其中disp16表示转移目标地址与jmp转移指令之间16位偏移量，也称为近转移
当偏移量是8位以内的时候，是短转移
有条件转移指令
jc label cf=1 有进位就跳转
jnc label 无进位就跳转
je/jz label zf=1　相等就跳转
jne/jnz label　不相等跳转
js label sf=1 负数，跳转
jns label sf=0 正数　跳转
jo label 有溢出　
....

循环控制指令

loop label cx!=0时跳转
loopz/loope label cx!=0 zf=1的时候跳转
loopnz/loopne cx!=0 zf=0的时候跳转
jcxz cx= 0的时候跳转

中断调用指令
在执行该指令的时候，会进行如下操作：
(1)psw、cs、ip入栈
(2)清除if，tf标志
(3)从中断向量表中取出中断向量
(4)转到中断调用程序子程序执行
(5)中断服务子程序的最后一条指令应该是中断返回指令，执行指令可以返回到中断处理处执行

中断返回指令
IRET

中断向量表
每个中断服务子程序的入口地址为32位，占用4个地址单元。计算机中采用最低1024个地址单元来存储中断向量
可以从该地址获得中断服务子程序的入口地址
movsb 字节传送　es:di<-ds:si  si<-si+/-1  di<-di+/-1
movsw 字传送　es:si<-ds:si si<-si+/-2  di<-di+/-2
movs dst, src 当dst和src为字节类型的时候，等同于movsb指令
为子类型的时候，等同于mowsw
mov var1, var2 完成了ds:si中的内容向es:di指定的位置

字符串比较指令
cmpsb  ds:si-es:di 字节操作
cmpsw ds:si-es:di　字操作
cmps dst,src

repz cmps  比较两个字符串，当遇到第一个不相同的字符时，就跳出比较循环　zf=0
repnz cmps　当遇到相等的两个字符的时候，就跳出比较循环

输入输出指令
端口输入指令　IN dst, src 表示cpu从端口读取数据，dst指定存取数据的寄存器，这里只能取ax, al
端口输出指令
